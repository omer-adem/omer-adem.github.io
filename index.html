<!DOCTYPE html>
<html lang="TR-tr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width"/>
    <title>FFF Brick Game</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22><rect width=%2216%22 height=%2216%22 fill=%22%2300008b%22/><text x=%224%22 y=%2212.5%22 font-size=%2212%22>ðŸ§±</text></svg>">
    <style>
        * { padding: 0; margin: 0; }
        canvas { 
            background: transparent; 
            display: block; 
            margin: 0 auto;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        body {
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .screen{
            width: 640px;
            left: 0%;
            height: 480px;
            opacity: 45%;
            text-align: center;
            align-items: center;
            justify-content: center;
            display: flex;
            position: absolute;
            pointer-events: none;
            top: 0;
        }
        .bg-greenyellow{
            background-color: greenyellow;
        }
        .bg-green{
            background-color: green;
        }
        .container{
            display: flex;
            justify-content: center;
            top:0;
        }
        .text-xlarge{
            font-size: xx-large;
            font-weight: bold;
            color:#00008b;
        }
        .text-large{
            font-size: x-large;
            font-weight: bold;
            color: green;
            position: relative;
            top: 10%;
        }
        .hidden{
            display:none;
        }
        .button-general{
            font-weight: bold;
            border-radius: 5px;
            width: 90px;
            display: inline-block;
            cursor: pointer;
            text-align: center;
            text-decoration: none;
            outline: none;
            border: none;
            box-shadow: 0 5px #999;
        }
        .btn-outer{
            height: 25px;
            margin-left: 10px;
            background-color: rgb(8, 118, 8);
            color:whitesmoke;
        }
        .btn-outer:hover{
            background-color: #3e8e41;
        }
        .btn-outer:active,.btn-inner:active{
            box-shadow: 0 3px #666;
            transform: translateY(2px);
        }
        .hinttext{
            padding: inherit;
            position: relative;
            top: 5px;
        }
        .hintSection{
            text-align: center;
            position: absolute;
            top: 95%;
            left: 15%;
            width: max-content;
        }
        .btn-inner{
            margin-left: 15px;
            height: 25px;          
            background-color: #00008b;
            color:whitesmoke;
        }
        .btn-inner:hover{
            background-color: #010148;
        }
        
        .touchpad-control {
            top: 110%;
            width: 100vh !important;
            height: 240px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            display: none;
            position: absolute;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            border: 3px solid rgba(255,255,255,0.2);
            overflow: hidden;
        }
        
        .touchpad-control.active {
            display: block;
        }
        
        .touchpad-inner {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .touchpad-indicator {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.6) 100%);
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease-out;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        
        .touchpad-label {
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            font-weight: bold;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            user-select: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .touchpad-arrows {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            pointer-events: none;
        }
        
        .touchpad-arrow {
            color: rgba(255,255,255,0.4);
            font-size: 30px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .game-end-css{
            left: 25%;
            position: relative;
        }
        
        /* Responsive touchpad for mobile devices */
        @media screen and (max-width: 680px) {
            .touchpad-control {
                width: 95%;
                max-width: 640px;
            }
        }

    </style>
</head>
<body>

<canvas id="myCanvas" width="640" height="480"></canvas>

<!-- Touchpad Control for Mobile -->
<div id="touchpadControl" class="touchpad-control">
    <div class="touchpad-inner">
        <div class="touchpad-arrows">
            <span class="touchpad-arrow">â—„</span>
            <span class="touchpad-arrow">â–º</span>
        </div>
        <div class="touchpad-label">SWIPE TO MOVE</div>
        <div id="touchpadIndicator" class="touchpad-indicator"></div>
    </div>
</div>

<div class="container">
    <div id="myPause" class = "screen bg-greenyellow hidden">
        <span class="text-xlarge"> Game Paused! </span> 
    </div>
    <div id="myGameOver" class = "game-end-css hidden">
        <span class="text-large"> Game Over, Wanna Try Again ?</span>
        <button class="button-general btn-outer" onclick="f_playGameOver()">Try Again!</button>
    </div>
    <div id="myGameWon" class = "game-end-css hidden">
        <span class="text-large"> You Won! Wanna Play Again ?</span>
        <button class="button-general btn-outer" onclick="f_playGameOver()">Play Again!</button>
    </div>
    <div id="myLevelStart" class = "screen bg-greenyellow hidden">
        <span class="text-xlarge"> Level <span id="levelNumber">1</span> </span> 
        <p class="text-large" style="margin-top: 20px;">Press arrow key or touch the control pad to start!</p>
    </div>
    <div id="myGameStart" class = "screen bg-greenyellow">
        <span class="text-xlarge" style="margin-top: 10%;"> Brick Game </span> 
        <div style="margin-top: 8%; display:flex; pointer-events:auto; flex-direction: column; align-items: center;">
            <label for="difficultySelect" class="text-large" style="top: 0; margin-bottom: 8px; color:#00008b;">Difficulty</label>
            <select id="difficultySelect" style="padding:4px 8px; border-radius:4px; margin-bottom: 12px;">
                <option value="easy" selected>Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
            </select>
            <button class="button-general btn-inner" onclick="f_play()"> Play! </button>
        </div>
    </div>
    <div class="hintSection">
        <h3>Hints</h2>
        <p class="hinttext">Press 'P' key to pause the game then press it again to continue.</p>
        <p class="hinttext">Mobile: Use the touchpad control below to move the paddle left/right!</p>
    </div>
</div>
<script>
    let canvas = document.getElementById("myCanvas");
    let ctx = canvas.getContext("2d");
    let x = canvas.width/2;
    let y = canvas.height-30;
    let dx = 4.0;
    let dy = -4.0;
    let ballRadius = 10;
    let Color = "red";
    let paddleHeight = 10;
    let paddleWidth = 110;
    let paddleX = (canvas.width-paddleWidth) / 2;
    let paddleSpeed = 12;
    let rightPressed = false;
    let leftPressed = false;
    let brickRowCount = 3;
    let brickColumnCount = 5;
    let brickWidth = 65;
    let brickHeight = 20;
    let brickPadding = 25;
    let brickOffsetTop = 25;
    let brickOffsetLeft = 25;
    let brickHitBoxWidthOffset = -2;
    let brickHitBoxHeigthOffset = 2;
    let score = 0;
    let paused = false;
    let gameover = false;
    let gamewon = false;
    let gamestart = true;
    let currentLevel = 1;
    let maxLevel = 4;
    let difficulty = 'easy';
    const difficultySpeeds = {
        easy: { dx: 3.0, dy: -3.0 },
        medium: { dx: 4.0, dy: -4.0 },
        hard: { dx: 5.0, dy: -5.0 }
    };
    let stars = [];
    let particles = [];
    let levelStart = false;
    let levelTransition = false;
    
    // Cache gradients to avoid recreating every frame
    let backgroundGradient = null;
    let vignetteGradient = null;
    
    // Performance optimization variables
    let frameCount = 0;
    let skipFrames = 0; // Skip some expensive operations every few frames
    function roundedRectPath(context, rx, ry, rw, rh, rr) {
        const r = Math.min(rr, rw / 2, rh / 2);
        context.beginPath();
        context.moveTo(rx + r, ry);
        context.lineTo(rx + rw - r, ry);
        context.quadraticCurveTo(rx + rw, ry, rx + rw, ry + r);
        context.lineTo(rx + rw, ry + rh - r);
        context.quadraticCurveTo(rx + rw, ry + rh, rx + rw - r, ry + rh);
        context.lineTo(rx + r, ry + rh);
        context.quadraticCurveTo(rx, ry + rh, rx, ry + rh - r);
        context.lineTo(rx, ry + r);
        context.quadraticCurveTo(rx, ry, rx + r, ry);
        context.closePath();
    }

    function initStars() {
        stars = [];
        for(let i = 0; i < 25; i++) { // Reduced from 50
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 1.5 + 0.5, // Reduced from 2
                speed: Math.random() * 0.3 + 0.1, // Reduced from 0.5
                opacity: Math.random() * 0.6 + 0.2 // Reduced from 0.8
            });
        }
    }

    function updateStars() {
        for(let i = 0; i < stars.length; i++) {
            const star = stars[i];
            star.y += star.speed;
            if(star.y > canvas.height) {
                star.y = 0;
                star.x = Math.random() * canvas.width;
            }
        }
    }

    function drawStars() {
        if(stars.length === 0) return;
        
        ctx.save();
        ctx.fillStyle = "#ffffff";
        for(let i = 0; i < stars.length; i++) {
            const star = stars[i];
            ctx.globalAlpha = star.opacity;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }

    function createParticle(x, y) {
        // Limit particles to prevent performance issues
        if(particles.length > 20) return;
        
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            life: 20, // Reduced from 30
            maxLife: 20,
            size: Math.random() * 2 + 1 // Reduced from 3
        });
    }

    function updateParticles() {
        for(let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if(p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    function drawParticles() {
        if(particles.length === 0) return;
        
        ctx.save();
        ctx.fillStyle = "#ffd700";
        for(let i = 0; i < particles.length; i++) {
            const p = particles[i];
            ctx.globalAlpha = p.life / p.maxLife;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }

    function initGradients() {
        // Create gradients once and cache them
        backgroundGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        backgroundGradient.addColorStop(0, "#0f2027");
        backgroundGradient.addColorStop(0.5, "#203a43");
        backgroundGradient.addColorStop(1, "#2c5364");
        
        const centerX = canvas.width/2;
        const centerY = canvas.height/2;
        const minDim = Math.min(canvas.width, canvas.height);
        const maxDim = Math.max(canvas.width, canvas.height);
        
        vignetteGradient = ctx.createRadialGradient(centerX, centerY, minDim/4, centerX, centerY, maxDim);
        vignetteGradient.addColorStop(0, "rgba(0,0,0,0)");
        vignetteGradient.addColorStop(1, "rgba(0,0,0,0.15)");
    }

    function drawBackground() {
        // Use cached gradients
        ctx.fillStyle = backgroundGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // subtle vignette
        ctx.fillStyle = vignetteGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawStars();
        drawParticles();
    }

    let bricks = [];
    
    function createLevel(level) {
        bricks = [];
        if(level === 1) {
            // Level 1: Original 4x6 grid
            brickRowCount = 5;
            brickColumnCount = 6;
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 0 };
                }
            }
        } else if(level === 2) {
            // Level 2: C shape
            brickRowCount = 7;
            brickColumnCount = 6;
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    let status = 1; // default to inactive
                    // Create C shape pattern
                    if(r === 0 || r === brickRowCount-1) {
                        status = 0; // active brick (left and right sides)
                    } else if(c === 0 || (c === brickColumnCount-1 && r == brickRowCount-1)) {
                        status = 0; // active brick (top and bottom)
                    }
                    bricks[c][r] = { x: 0, y: 0, status: status };
                }
            }
        } else if(level === 3) {
            // Level 3: X shape
            brickRowCount = 7;
            brickColumnCount = 7;
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    let status = 1; // default to inactive
                    // Create X shape pattern
                    if(c === r || c === brickRowCount - 1 - r) {
                        status = 0; // active brick
                    }
                    bricks[c][r] = { x: 0, y: 0, status: status };
                }
            }
        } else if(level === 4) {
            // Level 4: Random shape with more bricks
            brickRowCount = 7;
            brickColumnCount = 7;
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    let status = 0;
                    // Create random pattern (70% chance of active brick)
                    if(Math.random() < 0.3) {
                        status = 1; // inactive brick
                    }
                    bricks[c][r] = { x: 0, y: 0, status: status };
                }
            }
        }
        // Center bricks horizontally within the current canvas width
        const totalBrickWidth = (brickColumnCount * brickWidth) + ((brickColumnCount - 1) * brickPadding);
        brickOffsetLeft = Math.max(25, Math.floor((canvas.width - totalBrickWidth) / 2));
    }
    
    createLevel(currentLevel);
    
    // Touch controls for mobile devices
    let touchStartX = null;
    let lastTouchX = null;
    let touchActive = false;
    let lastFrameTime = Date.now();

    const gameStartElement = document.getElementById('myGameStart');
    const gameOverElement = document.getElementById('myGameOver');
    const gameWonElement = document.getElementById("myGameWon");
    const sel = document.getElementById('difficultySelect');
    const levelNumberElement = document.getElementById("levelNumber");
    const levelStartElement = document.getElementById("myLevelStart");
    const pauseElement = document.getElementById("myPause");
    const touchpadControl = document.getElementById("touchpadControl");
    const touchpadIndicator = document.getElementById("touchpadIndicator");

    function f_play(){
        if (gamestart)
            gameStartElement.classList.add("hidden");

        // read selected difficulty
        //const sel = document.getElementById('difficultySelect');
        if (sel) {
            difficulty = sel.value;
        }

        // Show touchpad control
        touchpadControl.classList.add("active");

        f_restart();
    }

    function f_playGameOver()
    {
        if (gameover)
            gameOverElement.classList.add("hidden");
        if (gamewon)
            gameWonElement.classList.add("hidden");

        gameStartElement.classList.remove("hidden");
        
        // Hide touchpad control
        touchpadControl.classList.remove("active");

        f_restart(false);
    }

    function f_restart(p_levelstart = true){
        x = canvas.width/2;
        y = canvas.height-30;
        dx = difficultySpeeds[difficulty].dx;
        dy = difficultySpeeds[difficulty].dy;
        paddleX = (canvas.width-paddleWidth) / 2;
        rightPressed = false;
        leftPressed = false;
        score = 0;
        paused = false;
        gameover = false;
        gamewon = false;
        gamestart = !p_levelstart;
        currentLevel = 1;
        levelStart = p_levelstart;
        levelTransition = false;
        particles = [];
        initStars();
        initGradients();
        createLevel(currentLevel);
        // Show level start screen
        if (p_levelstart)
        {
            levelNumberElement.textContent = currentLevel;
            levelStartElement.classList.remove("hidden");
        }
    }

    let audioCtx = null;
    let hitGain = null;

    function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        hitGain = audioCtx.createGain();
        hitGain.gain.value = 0.15;
        hitGain.connect(audioCtx.destination);
    }

    function playHitSound() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();

        osc.type = "square";
        osc.frequency.setValueAtTime(700, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.08);

        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.2, now + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);

        osc.connect(g);
        g.connect(hitGain);

        osc.start(now);
        osc.stop(now + 0.09);
    }

    function keyDownHandler(e) {
        if(e.key === "Right" || e.key === "ArrowRight") {
            rightPressed = true;
            initAudio();
            if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
            if(levelStart) {
                startLevel();
            }
        }
        else if(e.key === "Left" || e.key === "ArrowLeft") {
            leftPressed = true;
            initAudio();
            if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
            if(levelStart) {
                startLevel();
            }
        }
        else if (e.key === "p" && !gameover && !gamewon && !levelStart) {
            if(!paused)
                pauseElement.classList.remove("hidden");
            else pauseElement.classList.add("hidden");
            paused = !paused;
        }
    }

    function keyUpHandler(e) {
        if(e.key === "Right" || e.key === "ArrowRight") {
            rightPressed = false;
        }
        else if(e.key === "Left" || e.key === "ArrowLeft") {
            leftPressed = false;
        }
    }
    
    function getTouchPadPos(touchEvent, element) {
        const rect = element.getBoundingClientRect();
        const touch = touchEvent.touches[0] || touchEvent.changedTouches[0];
        if (!touch) return null;
        
        return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
            rect: rect
        };
    }
    
    function updateTouchpadIndicator(touchX, rect) {
        // Calculate percentage position within touchpad
        const percentage = touchX / rect.width;
        const clampedPercentage = Math.max(0, Math.min(1, percentage));
        
        // Update indicator position
        touchpadIndicator.style.left = (clampedPercentage * 100) + '%';
        
        // Scale indicator based on how far from center
        const distFromCenter = Math.abs(clampedPercentage - 0.5);
        const scale = 1 + (distFromCenter * 0.5);
        touchpadIndicator.style.transform = `translate(-50%, -50%) scale(${scale})`;
    }
    
    function touchStartHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if(e.touches.length === 0) return;
        
        const pos = getTouchPadPos(e, touchpadControl);
        if (!pos) return;
        
        // Initialize audio on first touch
        initAudio();
        if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
        
        touchActive = true;
        touchStartX = pos.x;
        lastTouchX = pos.x;
        lastFrameTime = Date.now();
        
        // Update visual indicator
        updateTouchpadIndicator(pos.x, pos.rect);
        
        // Start level if waiting
        if(levelStart) {
            startLevel();
        }
    }
    
    function touchMoveHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if(!touchActive || e.touches.length === 0) return;
        
        const pos = getTouchPadPos(e, touchpadControl);
        if (!pos) return;
        
        const currentTime = Date.now();
        const deltaTime = Math.max(1, currentTime - lastFrameTime);
        
        // Calculate the movement delta
        const deltaX = pos.x - lastTouchX;
        
        // Normalize to 60 FPS baseline (16.67ms per frame)
        const timeScale = deltaTime / 16.67;
        
        // Apply speed limit based on paddleSpeed
        const maxMove = paddleSpeed * timeScale;
        const clampedDelta = Math.max(-maxMove, Math.min(maxMove, deltaX));
        
        // Update paddle position
        paddleX += clampedDelta;
        
        // Keep paddle within bounds
        if(paddleX < 0) {
            paddleX = 0;
        } else if(paddleX + paddleWidth > canvas.width) {
            paddleX = canvas.width - paddleWidth;
        }
        
        // Update visual indicator
        updateTouchpadIndicator(pos.x, pos.rect);
        
        lastTouchX = pos.x;
        lastFrameTime = currentTime;
    }
    
    function touchEndHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        touchActive = false;
        touchStartX = null;
        lastTouchX = null;
        
        // Reset indicator to center with smooth transition
        touchpadIndicator.style.transition = 'all 0.3s ease-out';
        touchpadIndicator.style.left = '50%';
        touchpadIndicator.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // Remove transition after animation completes
        setTimeout(() => {
            touchpadIndicator.style.transition = 'all 0.1s ease-out';
        }, 300);
    }

    function drawBall() {
        const rg = ctx.createRadialGradient(x - ballRadius/3, y - ballRadius/3, ballRadius/3, x, y, ballRadius);
        rg.addColorStop(0, "#ffffff");
        rg.addColorStop(0.2, "#ffb3b3");
        rg.addColorStop(1, Color);
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 12;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI*2);
        ctx.fillStyle = rg;
        ctx.fill();
        ctx.restore();
    }

    function drawPaddle() {
        const px = paddleX;
        const py = canvas.height - paddleHeight;
        const pw = paddleWidth;
        const ph = paddleHeight;
        const grad = ctx.createLinearGradient(px, py, px, py + ph);
        grad.addColorStop(0, "#4facfe");
        grad.addColorStop(1, "#00f2fe");
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 3;
        roundedRectPath(ctx, px, py, pw, ph, 6);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.restore();
    }

    function drawBricks() {
        // Pre-calculate palette colors
        const palette = ["#ff7e5f", "#feb47b", "#6a82fb", "#fc5c7d", "#45b649"];
        
        for(let c=0; c<brickColumnCount; c++) {
            for(let r=0; r<brickRowCount; r++) {
                if(bricks[c][r].status===1){
                    continue;
                }
                let brickX = (c*(brickPadding + brickWidth)) + brickOffsetLeft;
                let brickY = (r*(brickPadding + brickHeight)) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;

                const g = ctx.createLinearGradient(brickX, brickY, brickX, brickY + brickHeight);
                // color by column for variety
                const base = palette[c % palette.length];
                g.addColorStop(0, base);
                g.addColorStop(1, "#1f1f1f");

                ctx.save();
                ctx.shadowColor = "rgba(0,0,0,0.35)";
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 3;
                roundedRectPath(ctx, brickX, brickY, brickWidth, brickHeight, 6);
                ctx.fillStyle = g;
                ctx.fill();
                ctx.restore();

                // subtle top highlight
                ctx.save();
                const hg = ctx.createLinearGradient(brickX, brickY, brickX, brickY + brickHeight);
                hg.addColorStop(0, "rgba(255,255,255,0.35)");
                hg.addColorStop(0.6, "rgba(255,255,255,0)");
                roundedRectPath(ctx, brickX, brickY, brickWidth, brickHeight, 6);
                ctx.fillStyle = hg;
                ctx.fill();
                ctx.restore();
            }
        }
    }

    function drawScore() {
        ctx.font = "16px Arial";
        ctx.fillStyle = "#0095DD";
        ctx.fillText("Score: "+score, 8, 20);
        ctx.fillText("Level: "+currentLevel, 8, 40);
    }

    function checkLevelComplete() {
        let activeBricks = 0;
        for(let c=0; c<brickColumnCount; c++) {
            for(let r=0; r<brickRowCount; r++) {
                if(bricks[c][r].status === 0) {
                    activeBricks++;
                }
            }
        }
        return activeBricks === 0;
    }

    function startLevel() {
        levelStart = false;
        levelTransition = false;
        levelStartElement.classList.add("hidden");
    }

    function nextLevel() {
        if(currentLevel == maxLevel) {
            victory();
        } else {
            currentLevel++;
            levelTransition = true;
            levelStart = true;
            createLevel(currentLevel);
            // Reset ball position for new level
            x = canvas.width/2;
            y = canvas.height-30;
            dx = difficultySpeeds[difficulty].dx;
            dy = difficultySpeeds[difficulty].dy;
            paddleX = (canvas.width-paddleWidth) / 2;       
            // Show level start screen
            levelNumberElement.textContent = currentLevel;
            levelStartElement.classList.remove("hidden");            
        }
    }

    function victory()
    {
        drawBackground();
        drawBall();
        drawPaddle();
        drawScore();
        gamewon = true;
        gameWonElement.classList.remove("hidden");
    }

    function collisionDetect()
    {
        // Identify which brick cells the ball is near to reduce checks
        let c = Math.floor((x - brickOffsetLeft) / (brickPadding + brickWidth));
        let r = Math.floor((y - brickOffsetTop) / (brickPadding + brickHeight));
        let endC = c + 1;
        let endR = r + 1;

        // Clamp search window to grid
        if (endC > brickColumnCount - 1) { c = brickColumnCount - 1; endC = c; }
        if (c < 0) { c = 0; endC = c; }
        if (endR > brickRowCount - 1) { r = brickRowCount - 1; endR = r; }
        if (r < 0) { r = 0; endR = r; }

        // Helper clamp
        function clamp(value, min, max) { return Math.max(min, Math.min(max, value)); }

        // Try to resolve at most one collision per frame
        for (let i = c; i <= endC; i++) {
            for (let j = r; j <= endR; j++) {
                if (bricks[i][j].status !== 0) {
                    continue;
                }
                const rectX = bricks[i][j].x;
                const rectY = bricks[i][j].y;
                const rectW = brickWidth;
                const rectH = brickHeight;

                // Find closest point on the rectangle to the ball center
                const closestX = clamp(x, rectX, rectX + rectW);
                const closestY = clamp(y, rectY, rectY + rectH);

                const distX = x - closestX;
                const distY = y - closestY;
                const distSq = distX * distX + distY * distY;

                if (distSq <= ballRadius * ballRadius) {
                    // Compute overlap depths toward each side
                    const overlapLeft = (x + ballRadius) - rectX;              // penetrating left side
                    const overlapRight = (rectX + rectW) - (x - ballRadius);   // penetrating right side
                    const overlapTop = (y + ballRadius) - rectY;               // penetrating top side
                    const overlapBottom = (rectY + rectH) - (y - ballRadius);  // penetrating bottom side

                    // Choose the smallest positive overlap to decide impact side
                    const minHoriz = Math.min(Math.abs(overlapLeft), Math.abs(overlapRight));
                    const minVert = Math.min(Math.abs(overlapTop), Math.abs(overlapBottom));

                    if (minHoriz < minVert) {
                        // Horizontal collision: invert dx and nudge out of brick
                        if (Math.abs(overlapLeft) < Math.abs(overlapRight)) {
                            // Hit brick's left face
                            dx = -Math.abs(dx);
                            x = rectX - ballRadius; // position just left of brick
                        } else {
                            // Hit brick's right face
                            dx = Math.abs(dx);
                            x = rectX + rectW + ballRadius; // position just right of brick
                        }
                    } else {
                        // Vertical collision: invert dy and nudge out of brick
                        if (Math.abs(overlapTop) < Math.abs(overlapBottom)) {
                            // Hit brick's top face
                            dy = -Math.abs(dy);
                            y = rectY - ballRadius; // position just above brick
                        } else {
                            // Hit brick's bottom face
                            dy = Math.abs(dy);
                            y = rectY + rectH + ballRadius; // position just below brick
                        }
                    }

                    bricks[i][j].status = 1;
                    score++;
                    playHitSound();                  
                    // Check if level is complete
                    if(checkLevelComplete()) {
                        nextLevel();
                    }
                    else{
                        // Create particle effect (reduced frequency)
                        for(let p = 0; p < 5; p++) { // Reduced from 5 to 3
                            createParticle(rectX + rectW/2, rectY + rectH/2);
                        }
                        
                    }
                    return; // handle one brick per frame to prevent double hits
                }
            }
        }
    }

    /*let secondsPassed;
    let oldTimestamp;
    let fps;

    secondsPassed = (timestamp - oldTimestamp) / 1000;
    oldTimestamp = timestamp;

    fps = Math.round(1 / secondsPassed);*/

    function draw() {
        //frameCount++;
        
        if (paused || gameover || gamewon)
        {
            requestAnimationFrame(draw);
            return;
        }
        
        // Always draw background, but skip some expensive effects occasionally
        //if (frameCount % 2 === 0) {
        drawBackground();
        //} else {
            // Simplified background without stars/particles every other frame
        //    ctx.fillStyle = backgroundGradient;
        //    ctx.fillRect(0, 0, canvas.width, canvas.height);
        //    ctx.fillStyle = vignetteGradient;
        //    ctx.fillRect(0, 0, canvas.width, canvas.height);
        //}
        
        drawBall();
        drawBricks();
        drawPaddle();
        drawScore();
        
        if (gamestart || levelStart)
        {
            requestAnimationFrame(draw);
            return;
        }
        x += dx;
        y += dy;
        
        // Update animations less frequently
        if (frameCount % 2 === 0) {
            updateStars();
        }
        updateParticles();
        collisionDetect();
        if((x+ballRadius >= canvas.width && dx>=0) || (x-ballRadius <= 0 && dx<=0)) {
            dx *= -1;
            if(dx==0)
                dx+=0.1;
        }
        if(y-ballRadius <= 0) {
            dy *= -1;
        }
        else if(y + ballRadius > canvas.height - 10){
            if(x+7 > paddleX && x-7 < paddleX + paddleWidth && dy > 0) {
                dy *= -1.03;
                if (x < paddleX + paddleWidth/2)
                    dx -= ((paddleWidth/2) - (x-paddleX))/(paddleWidth/2);
                else
                    dx += ((paddleWidth/2) - (paddleX + paddleWidth-x))/(paddleWidth/2);
            }
            else if(y + ballRadius > canvas.height+3){
                y-=30;
                gameover = true;
                gameOverElement.classList.remove("hidden");
            }
        }
        if(rightPressed) {
            paddleX += paddleSpeed;
            if (paddleX + paddleWidth > canvas.width){
                paddleX = canvas.width - paddleWidth - 1;
            }
        }
        else if(leftPressed) {
            paddleX -= paddleSpeed;
            if (paddleX < 0){
                paddleX = 1;
            }
        }
        requestAnimationFrame(draw);
    }
    
    // Register event listeners after all functions are defined
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    
    // Attach touch events to touchpad control element
    touchpadControl.addEventListener("touchstart", touchStartHandler, { passive: false });
    touchpadControl.addEventListener("touchmove", touchMoveHandler, { passive: false });
    touchpadControl.addEventListener("touchend", touchEndHandler, { passive: false });
    touchpadControl.addEventListener("touchcancel", touchEndHandler, { passive: false });
    
    requestAnimationFrame(draw);
</script>

</body>
</html>
